---
title: JavaScript 执行过程
tags: [JavaScript]
category: JavaScript
date: 2020-3-28 17:20
---
# JavaScript 执行过程

## 解释性语言
先来聊聊其他的，JavaScript 是一门解释性语言，所谓解释性语言，就是人类能够理解的语言，它需要转换成机器能够理解的语言才能够执行，这个转换是在运行的时候才进行的。

### 解释器和编译器
解释器是在程序运行时对代码进行逐行转义，优点就是不必等待即可运行，缺点是由于是即时性的，导致对于循环类的代码无法进行优化，重复编译导致运行低效。
编译器是在程序运行前就对代码进行转义并保存，优点是它可以有更多的时间对代码进行查看和优化，缺点就是耗时。
早期的浏览器大多使用解释器，后来为了解决低效问题，就有了把两者混合起来的 JIT。

### JIT
JIT（Just In Time）即时编译器融合了两者的优点，在一句一句编译源代码的同时，又会将一些编译后的代码保存下来。

#### 监视器（Monitor）
监视器监控着代码的运行情况，如果一段代码运行了几次（run a few times），那么这段代码会被标记为“warm”代码，如果一段代码运行和很多次（run a lot），那么这段代码会被标记为“hot”代码。

#### 基线编译器（Baseline compiler）
如果一段代码被标记成了“warm”，JIT 会把这段代码送到基线编译器编译，同时把结果缓存起来。
如果一个函数被基线编译器编译，那么这个函数的每一行都会被编译成一个表，这个表的索引是行号和变量类型，如果监视器再次发现有代码使用相同的变量类型命中这段代码的时候，JIT 会直接提取这段代码编译后的内容。

#### 优化编译器（Optimizing compiler）
如果一段标记为“warm”的代码还在不断被调用，那么它会被标记为“hot”，被标记为“hot”的代码可能会经常被调用，所以可能需要花更多的时间优化它的编译结果。监视器会把该段代码送到优化编译器中，编译成一个高效的版本并存储下来。

优化编译器是如何做的？实际上优化编译器会做出一些假设（类似于世代假说）：
比如说很多代码会调用一个构造函数生成一个对象，他们的结构都相同（属性名相同，同时属性添加的顺序也一样），举个例子：

```javascript
for (let i = 0; i < arr.length; i++) {
  sum += arr[i]
}
```
在 JIT 实际运行的时候逻辑十分复杂，因为它不能确定`arr[i]`的类型，所以它需要执行一系列检查：`sum`是不是数字，`arr`是不是一个数组，`i`是不是一个数字，`arr[i]`是不是一个数字...每一个条件都有两个分叉，所以这段代码在基线编译器编译后的表中是非常复杂的，每次代码运行，JIT 都会要重新再问一次上面的问题，根据问题的结果从表中取出相应代码，这样效率就会慢很多，如果经过优化之后他就可以指直接对`sum`、`arr`、`i`的类型做出假设，从而避免了复杂的判断。

不过事实上这种假设是不能保证的，所以经过编译后的代码在运行前会检查这个假设是不是有效，如果真的是有效的，那么运行代码，否则销毁这段编译后的代码，把版本回退到基线编译器或者是解释器的版本。

通常情况下，这种优化是有助于性能的，不过也有些以外，如果这种假设不成立的事一直发生，代码的运行速度就会比基线编译的还慢（负优化），所以很多浏览器加了一些限制条件，比如说如果 JIT 优化了十次都是不成功的，那么 JIT 就停止优化。

## 编译
下面以 V8 为例子看看 JavaScript 是如何运行的。
![V8 流程](https://static.gongfangwen.com/2020-03-28-15853880491105.jpg)

### Parse 阶段
#### 词法分析
词法分析是把需要执行的代码字符串分割出来，生成一系列 token，便于做语法分析下面是一个例子：
分析前：
```
var sum = 'fawen';
```

分析后：

```javascript
[
    {
        "type": "Keyword",
        "value": "var"
    },
    {
        "type": "Identifier",
        "value": "sum"
    },
    {
        "type": "Punctuator",
        "value": "="
    },
    {
        "type": "String",
        "value": "'fawen'"
    }
]
```


#### 语法分析：
语法分析分析上述输出，输出 AST 抽象语法树，如果分析发现异常则抛出。
![AST](https://static.gongfangwen.com/2020-03-28-15853874460897.jpg)

### Ignition
Ignition 就是 V8 的解释器，它会根据抽象语法树生成对应的字节码并执行。
所谓字节码，就是机器码的抽象，机器码虽然运行效率最高，但是占用空间很大，导致十分占内存，所以以时间换空间，引入了字节码。
![字节码的关系](https://static.gongfangwen.com/2020-03-28-15853882460066.jpg)

### Turbofan
Turbofan 能够把字节码编译成机器码，当发现“hot”代码的时候，Turbofan 会把字节码编译成机器码，之后就调用生成的机器码，如果发现假设失败，再把代码回退成字节码。

### Orinoco
Orinoco 是 V8 的垃圾回收模块，详见之前的<a href="https://blog.gongfangwen.com/2020/03/17/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" target="_blank">V8 中的垃圾回收</a>。

## 执行
### 执行上下文和执行栈
执行上下文就是 JavaScript 的运行环境，通常有三种：
- 全局执行上下文，即 window 对象
- 函数执行上下文，在函数执行的时候被创建，每次调用函数都会创建一个新的执行上下文
- ~~eval 执行上下文~~

对于每个执行上下文创建的时候，都有三个比较重要的属性：
- 变量对象，表示执行上下文的数据作用域，存储了执行上下文的变量（如 arguments 等）、函数等。
- 作用域链，在执行上下文中查找变量的时候会现在当前上下文对象中查找，如果没有就从父级（函数定义）的上下文对象中查找，直到全局对象。
- 确定 this 指向，一般情况下是谁调用指向谁。

JavaScript 通过执行栈管理多个执行上下文，执行栈最底端是全局上下文，全局上下文中执行函数的时候，相应上下文会入栈，其中不断调用函数，不同的函数不断入栈创建不同的执行上下文，直到函数执行完毕，上下文出栈，即后进先出，如果有异步函数，在执行栈空的时候查看任务队列，微任务优先入栈，这里可以查看之前的<a href="https://blog.gongfangwen.com/2020/03/18/%E7%BB%86%E8%AF%B4%20JavaScript%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%20%E2%80%94%E2%80%94%20Event%20Loop/" target="_blank">Event Loop</a>。

最后，V8 通常有两种方式执行代码：
- 在生成 AST 后，Ignition 就已经能根据 AST 生成并执行字节码了；
- 发现“hot”代码后，执行 Turbofan 优化后的代码。


## 参考
- [A crash course in just-in-time (JIT) compilers](https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/)
- [理解 V8 的字节码「译」](https://zhuanlan.zhihu.com/p/28590489)
- [JavaScript 引擎 V8 执行流程概述](https://segmentfault.com/a/1190000021297142)
- [JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)