---
title: 机器码与按位运算
tags: [Javascript]
category: JavaScript
date: 2020-3-19 17:31
---
# 机器码与按位运算

## 前言
前几天看`Lodash`里面有移位操作，作为把知识还给老师的我又是一脸懵逼了，所以今天来看看机器码和 JavaScript 的那些坑，下一篇再写写`IEEE754`那些事。

## 基础概念
首先我们知道计算机是以机器码来存储数值的，其中包括原码、反码、补码、移码等，接下来先以`8 bits`的有符号数为例，一个个来了解一下。
### 原码
最高位表示正负（`0`为正`1`为负），其余位表示数值，如：
- `+5`可以表示为`00000101`
- `-4`可以表示为`10000100`

由于最高位表示符号，所以`10000100`说对应的真实数值是`-4`而不是`131`，这个`-4`就称为机器码的**真值**。
原码主要表示了真实的数值，便于人计算，但是对于机器不易理解，于是就有了反码。

### 反码
正数的反码等于其原码本身，负数的反码则是对原码进行“符号位不变，其他位取反”的结果，如：
- `+7`的原码为`00000111`，反码为`00000111`
- `-7`的原码为`10000111`，反码为`11111000`

有了反码，对于加法，机器就能很好的进行计算了，可以用如下步骤：
1. 将数字转化成原码
2. 将原码转换成反码
3. 反码加法计算（如果最高位进位，那么最低位加一）
4. 结果再转换成原码（正值不变，负值除了符号位按位取反）


```
7 - 7 = 7 + (-7)
      = [00000111]原 + [10000111]原
      = [00000111]反 + [11111000]反
      = [11111111]反
      = [10000000]原
      = -0
```
有了反码，机器就能很好理解加减法了，但是但是，这个`0`怎么还有正负，强迫症不能忍，于是又有了补码。

### 补码
正数的补码等于其原码，负数的补码等于其**反码末位加1**，如：
-  `5`的原码等于`00000101`，反码等于`00000101`，补码等于`00000101`
- `-5`的原码等于`10000101`，反码等于`11111010`，补码等于`11111011`

接着进行刚才的运算：
```
7 - 7 = 7 + -7
      = [00000111]原 + [10000111]原
      = [00000111]反 + [11111000]反
      = [00000111]补 + [11111001]补
      = [00000000]补
      = [00000000]反
      = [00000000]原
      = 0
```
这样一来，`0`的符号就舍去了，也不用对补码最高位的进位做额外的加法工作，岂不美哉？
对于补码的表示范围，因为有了加1的操作，现规定**[10000000]补 可表示 128**。

### 移码与阶码
移码是补码的符号位取反，阶码等于移码减1。主要用于浮点数，这个稍后在深入研究。

## 按位运算
在 JavaScript 中，主要有如下几种二进制的按位运算：

| 运算    | 操作符     | 解释                                       |                     |
|-------|---------|------------------------------------------|---------------------|
| 按位与   | `a & b`   | 每一位都为 1，结果为 1，否则为 0                      |                     |
| 按位或   | <code>a &#124; b</code>                                        | 每一位若有 1，结果为 1，否则为 0 |
| 按位异或  | `a ^ b`   | 每一位只有一个 1，结果为 1，否则为0                     |                     |
| 按位非   | `~a`      | 每一位 0 变成 1，1 变成 0                        |                     |
| 左移    | `a << b`  | a 的二进制形式向左移动 b 位，右边以 0 填充，b < 32         |                     |
| 有符号右移 | `a >> b`  | a 的二进制形式向右移动 b 位，丢弃被移出的位，b < 32          |                     |
| 无符号右移 | `a >>> b` | a 的二进制形式向右移动 b 位，丢弃被移出的位，左边以 0 填充，b < 32 |                     |

下面以 8 位为例，一个个解释一下：

### 按位与
```javascript
// 1 的二进制表示为 00000001
// 2 的二进制表示为 00000010
// 00000001 & 00000010 = 00000000 = 0
console.log(1 & 2); // 0
```

实际应用：
- 判断奇数偶数，根据奇数最后一位为 1，那么可以把要判断的数和 1 按位与，如果结果等于 1，那么就是奇数，等于 0 就是偶数。

### 按位或
```javascript
// 1 的二进制表示为 00000001
// 2 的二进制表示为 00000010
// 00000001 | 00000010 = 00000011 = 3
console.log(1 | 2); // 3
```

### 按位异或
```javascript
// 1 的二进制表示为 00000001
// 2 的二进制表示为 00000010
// 00000001 ^ 00000010 = 00000011 = 3
console.log(1 ^ 2); // 3
// 00000010 ^ 00000011 = 00000001 = 1
console.log(2 ^ 3); // 1
```
可以应用按位异或来交换数值：
```javascript
var a = 10,b = 9;
a^=b;
b^=a;
a^=b;
console.log(a, b); // 9 10
```

### 按位非
```javascript
// 7 的二进制表示为 00000111
// ~00000111 = [11111000]补 = [111110111]反 = [10001000]原 = -8
// 由于按位非之后得到了负数，在 JavaScript 中负数用补码表示，所以要求其原码
console.log(~7); // -8
```
发现一个整数 a 的按位非等于`-a - 1`，我们可以根据这个做一些应用：
 - `indexOf`，由于`indexOf`如果未找到返回`-1`，那么正好`~-1`等于`0`，使用按位非有助于判断
 - 两次按位非取整，`~~1.2 = 1`，使用这种方法既简单又快速

### 左移
```javascript
// 1 的二进制表示为 00000001
// 0000001 << 1 = 00000010 = 2
console.log(1 << 1); // 2
console.log(1 << 3); // 8
```
左移可以用这个公式来表示：
```javascript
a << b = a * (2 ** b)
```
左移的实际应用主要有将 RGB 颜色转成 16 进制，我们都知道，RGB 值是从`0 ~ 255`，正好可以由 8 位来表示，因此，一个 RGB 颜色可以使用`3*8=24`位来表示（红绿蓝各 8 位），比如`chocolate`我们可以这么来表示：
```
chocolate = rgb(210, 105, 30)
      Red = 210 = 11010010 = d2
    Green = 105 = 01101001 = 69
     Blue = 30  = 00011110 = 1e
     
      hex = 00000000 11010010 01101001 00011110 = #d2691e
```
把上面三个数分别用 32 位来表示，然后进行左移，按照红绿蓝的顺序分别移动16、8、0位：
```
      Red = 210 = 00000000 00000000 00000000 11010010
    Green = 105 = 00000000 00000000 00000000 01101001
     Blue = 30  = 00000000 00000000 00000000 00011110
     
      Red << 16 = 00000000 00000000 00000000 11010010 << 16
                = 00000000 11010010 00000000 00000000
     Green << 8 = 00000000 00000000 00000000 01101001 << 8
                = 00000000 00000000 01101001 00000000
      Blue << 0 = 00000000 00000000 00000000 00011110
      
三个数结果做按位或 = 00000000 11010010 01101001 00011110 = #d2691e
```
这样就得到了一个 RGB 颜色的 16 位表示，用函数表示就是：
```javascript
function rgbToHex(red, green, blue) {
    return `#${(red << 16 | green << 8 | blue).toString(16)}`
}

console.log(rgbToHex(210,105,30)); // #d2691e
```

### 有符号右移
> 向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。

对于正数来说比较符合逻辑：
```javascript
// 7 的二进制表示为 00000111
// 00000111 >> 2 = 00000001 = 1
console.log(7 >> 2); //1
```

对于负数，由于使用补码，说所以需要做一层转换：
```javascript
// -7 = [10000111]原 = [11111000]反 = [11111001]补
// 11111001 >> 2 = (**)111110 = 拷贝最左侧填充左侧 = [11111110]补 = [11111101]反 = [10000010]原 = -2
console.log(-7 >> 2); // -2
```

同样的，可以有符号右移可以用来提取 RGB 颜色：
```
    #d2691e = 00000000 11010010 01101001 00011110
    
    

    
```
分别对颜色做右移 16、8、0 位：
```
    00000000 11010010 01101001 00011110 >> 16 = 00000000 00000000 00000000 11010010
    00000000 11010010 01101001 00011110 >> 8  = 00000000 00000000 11010010 01101001
    00000000 11010010 01101001 00011110 >> 0  = 00000000 11010010 01101001 00011110
    
```
由于只有最开始 8 位是实际的颜色值，所以可以做按位与运算屏蔽其他位：
```
    00000000 00000000 00000000 11010010
  & 00000000 00000000 00000000 11111111
  = 00000000 00000000 00000000 11010010
  = 210
   
    00000000 00000000 11010010 01101001
  & 00000000 00000000 00000000 11111111
  = 00000000 00000000 00000000 01101001
  = 105
  
    00000000 11010010 01101001 00011110
  & 00000000 00000000 00000000 11111111
  = 00000000 00000000 00000000 00011110
  = 30
```
用函数表示：
```javascript
function hexToRgb(hex) {
    const number = Number(`0x${hex.replace(/^#?([0-9a-f]{6})$/i, '$1')}`);
    // $1 表示第一个括号匹配的字符串
    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace
    return `rgb(${number >> 16 & 0xff }, ${number >> 8 & 0xff }, ${number & 0xff })`
}
```

### 无符号右移
无符号右移与有符号右移的最大区别就是是否保留符号位，对于无符号右移来说，结果永远是无符号整数。
```javascript
// 7 的二进制表示为 00000111
// 00000111 >>> 2 = 00000001 = 1
console.log(7 >>> 2); // 1
// -7 的二进制表示为 [10000000 00000000 00000000 00000111]原
// = [11111111 1111111 1111111 11111000]反
// = [11111111 1111111 1111111 11111001]补
// 11111111 1111111 1111111 11111001 >>> 2
// = 00111111 11111111 11111111 11111110
// = 1073741822
console.log(-7 >>> 2); // 1073741822
```

### 其他应用
> 不使用加减法得到两数字和（leetcode 371）：对于两个整数a, b，a ^ b 是无进位的相加，a & b 得到每一位的进位；让无进位相加的结果与进位不断的异或，直到进位为 0。
> ```javascript
> var getSum = function(a, b) {
>  if (a === 0 || b === 0) {
>    return a || b;
>  }
>  let temp;
>  while (b != 0) {
>    temp = a ^ b;
>    b = (a & b) << 1;
>    a = temp;
>  }
>  return a;
>};
> ```
> ```
>    2 + 3
>  = 0010 + 0011
>  => temp = 0010 ^ 0011 = 0001
>  => b = 0010 & 0011 = 0010 << 1 = 0100
>  => a = 0001
>  => temp = 0001 ^ 0100 = 0101
>  => b = 0101 & 0001 = 0001 << 1 = 0010
>  => a = 0101
>  => temp = 0101 ^ 0010 = 0111
>  => b = 0101 & 0010 = 0000 << 1 = 0
>  => a = 0101 = 5
> ```
## 参考
- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)
- [【译】JavaScript中按位操作符的有趣应用](https://juejin.im/post/5d5ca4daf265da038f481104)
