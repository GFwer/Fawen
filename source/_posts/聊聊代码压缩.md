---
title: 聊聊代码压缩
tags: [JavaScript]
category: JavaScript
date: 2020-4-23 22:13
---
# 聊聊代码压缩


## 前言
通常在升级线上环境的时候，为了缩小代码的体积，我们通常会选择压缩代码资源，这背后的原理又是什么，不禁让人好奇起来。

## HTML 压缩
通常来说对 HTML 文件压缩需求不是很大，因为现在 HTML 几乎都只充当模板文件，压缩意义不是很大，如果非要压缩的话也不是不行，主要还是针对空格的处理，除了`pre`标签这种有影响的之外，其余的空格都可以删除，其中引用的 JS 文件和 CSS 文件可以继续往下看。

## CSS 压缩
CSS 压缩先对来说也比较简单，首先可以去除空格、换行和注释，如果分析语义的话，可以合并重复的语句（不过这个还是 lint 来做比较好）

## JS 压缩
JS 压缩能讲的就比较多了，通常用的比较多的是 UglyfyJS，主要过程如下
- 首先需要把 JavaScript 代码生成 AST 抽象语法树
- 遍历、修改 AST
- 修改后的 AST 生成新代码

减小体积，说白了就是减少代码的长度，除了基本的空格换行之外，还可以通过这些来做：
### 计算可以计算的表达式

对于一些`1 + 1`这样的表达式来说，可以直接计算出结果：
```javascript
// 前
var x = 1 + 1
// 后
var x=2
// 前
var x = 1 / 3
// 后，不压缩
var x=1/3
```

### 优化布尔类型
对于布尔类型来说，有效减少长度的方法就是通过隐式强制类型转换：
```javascript
// 前
var bool = true
// 后
var boll=!0
// 前
var bool = false
// 后
var bool=!1
```

### 优化赋值表达式
对于`a = a + b`这种类型的表达式，可以优化成`a+=b`，对于加减乘除位运算都可以生效：
```javascript
// 前
a = a + b
a = a | b
// 后
a+=b
a|=b
```

### 去除无用的参数
函数中没用到的形参完全可以去除：
```javascript
// 前
function fn(x, y, z) {
    return x + y
}
// 后
function fn(x,y){return x+y}
```

### 去除无用的代码块
永远达不到的块可以去除：
```javascript
if (false) {

}
while (false) {

}
```
还有`return`
```
function add(x, y){
    return x + y
    console.log(x);
}
```

### 去除 switch 最后一个 break
switch 的最后一个 break 可以去除：
```javascript
// 前
switch(A){
    case 'a':
        break;
    case 'b':
        break;
}
// 后
switch(A){
    case 'a':
        break;
    case 'b':
}
```

### 调转三元运算符
如果三元运算符中存在`!`形式可以调转：
```javascript
// 前
var x = !bool? a : b;
// 后
var x=bool?b:a;
// 如果 bool 是直接可以判断的
// 前
var x = true?a : b;
// 后
var x = a
```

### 重复声明压缩
多个连续声明可以合成一个：
```javascript
// 前
var a
var b
// 后
var a,b
```

### 常数判定去除
如果对于判断条件中可以直接计算出来的结果，会直接抛弃执行不到的片段：
```javascript
// 前
if(1) fn()
else{}
// 后
fn()
```

### 变量压缩
使用简短的变量替换长的变量：
```javascript
// 前
function lllllllllongfn(llllla,lllllb){
    return llllla + lllllb
}
// 后
function a(b,c){return b+c}
```

其它还有很多很多相应的规则，这里不再赘述了

## Source Map
压缩完成之后，线上代码已经变成了几乎不可读的形式了，那么如何 debug 呢？

那就是通过 map 文件维护一个映射来了解混淆后代码在原代码中的位置。

那么 Source Map 是如何做的呢？

首先可能想到的是：每个字符都维护一个映射，记录第几行第几列，这种方法简单：
```
var a = 'Fawen'
    源文件     压缩后     文件名
v 1 行，1列   1 行，1列    xxx.js
a 1 行，2列     ...
r 1 行，3列
a 1 行，5列
```
通过`|`分割，看起来可能就像这样：
```
1|1|xxx.js|1,1
```
然而随着代码量的增多，map 文件的大小恐怕是个大问题，这种方法显然不实际。

实际上，可以通过很多方法来优化：

### 去除行号
由于压缩之后的代码行数一般较少，通过移除输出的行号来减少体积，通过`;`来分割不同的行号
```
1|xxx.js|1,1;
// 输出文件列位置|输入文件名|输入文件行号|输入文件列号;第二行内容;第三行内容
```

### 提取文件名
文件名也是重复比较多的字段，可以文件名单独提取出来：
```
source: ['aaa.js']
mappings: 1|0|1|1
// 输出文件列位置|文件名索引|输入文件行号|输入文件列号;第二行内容;第三行内容
```

### 可符号化的字段提取
对于一些字段来说，知道了它们第一个字段的位置，后面的位置也就不用关心了，比如`Fawen`，知道了`F`的位置，后面的就不用在写在映射中了：
```
source: ['aaa.js']
names: ['Fawen']
mappings: ....
```

### VLQ
通过上面这些步骤，map 文件字符数量已经大大减少了，现在可以尝试对`|`分割符做优化了，比如如果分割的都是一位数，可以去除分割符：
```
// 前
1|2|3|4
// 后
1234
// 前
1|2|34|5
// 后
？？？
```
对于两位数及更多位的数字直接去除分割符的方式显然不太好，通过 VLQ 编码的方式就可以精简地表示大数：
![VLQ](https://static.gongfangwen.com/2020-04-24-VLQ.png)

VLQ 是用任意两个字节组去表示一个任意数字的编码形式，他的主要格式如下：
```
B5 B4 B3 B2 B1 B0
C     Value    S   
```
- 一组 6 个二进制位
- C 表示之后是否跟着另一个字节组，0 表示这是最后一个，1 表示后面还跟着有数
- Value 代表实际的二进制数
- 在第一组 中，S 代表符号位，0 为正，1 为负，其他组中表示二进制数

下面是对于`12|3|456|7`做一个说明：
先转化为二进制数：
```
12  => 1100
3   => 0011
456 => 111001000
7   => 0111
```
再对其中各个数按照 VLQ 进行编码：
```
1100      => 011000
0011      => 000110
111001000 => 110000 011100 // 从后往前
0111      => 001110
// 得到结果
          => 011000 000110 110000 011100 001110
          => 24 6 48 28 14
// 查表转换
          => YGwcO
```

这样就能有效缩短位数了。

当然实际上 Source Map 的原理不止这些，今天主要是通过 VLQ 这个主要的手段来了解了解，并不深入，期待以后有机会再能深入学习一下。
