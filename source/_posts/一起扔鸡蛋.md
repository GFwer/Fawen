---
title: 一起扔鸡蛋
tags: [Algorithm]
category: Algorithm
date: 2020-04-07 23:11
---
# 一起扔鸡蛋

## 前言
今天的我又是被算法血虐的一天，来个问题吧：

> 如果有 100 层楼，给你 2 个鸡蛋，鸡蛋很坚硬，从 X 层扔下鸡蛋会碎裂，X 层以下怎么扔都不会碎，你想知道 X 的值，设计方案求最少扔几次？

## 解法分析

### 二分法
二分法可能是一开始很多人想的解决方案，解决方法如下：

在 50 层扔下鸡蛋，如果碎了去 1 层开始扔鸡蛋，如果没碎，去 75 层扔鸡蛋...

最坏情况下，X = 49，在 50 层扔下鸡蛋，鸡蛋碎了，这时候只剩下一个鸡蛋，所以只能从 1 层开始，一直扔到 49 层，这种方法的次数为 50 次。

### 平方根法
从根号 100，即 10 层开始扔鸡蛋，如果没碎就在 20 层扔，如果碎了就从 1 层开始扔...

最坏情况下，X = 100，第一个鸡蛋在第十次碎了，从 91 层开始，直到第 99 层，这种方法次数为 19 次。

### 分析
假设 n 为最坏情况下的次数，那么第一次扔的楼层为 n，有两种情况：
- 碎了，那么接下来需要从`[1, n - 1]`遍历扔，最多扔`n - 1`次
- 没碎，接下来从`[n + 1, 100]`继续考虑怎么扔的问题，最多扔`n - 1`次

如果没碎接下来该怎么扔呢？转化成了在`[n + 1, 100]`层用两个鸡蛋求解的问题，在`n + (n - 1)`层扔：
- 碎了，接下来从`[n + 1, n + (n - 1) - 1]`中扔，最多扔`n - 2`次
- 没碎，接下来从`[n + (n - 1) + 1, 100]`中扔，最多`n - 2`次，在`n + (n - 1) + (n - 2)` 层扔。


继续扔，`n + (n - 1) + (n - 2) + (n - 3) + ....`，最后一次在`n - n - 1`处能够确认，得出方程
```
    n + (n - 1) + (n - 2) + ... + 1
=>  n(n + 1)/2
```
最差情况下，这个方程能够等于 100 层，解方程结果向上取整得`n = 14`。

即最开始以 14 为单位扔鸡蛋。

## 扩散
现在改成把层数和鸡蛋数量都变成变量：
> 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

> 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

> 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

> 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
> 你的目标是确切地知道 F 的值是多少。

> 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

### 动态规划
这道题打死我都想不到动态规划...

设定 dp，`dp[k][m]`的含义是`k`个鸡蛋 移动`m`次最多能够确定的楼层数量，
在第一次扔鸡蛋后，有两种结果，碎了或者没碎，
碎了的问题就变成了，剩下`k - 1`个鸡蛋，移动`m - 1`次能确定的楼层数量，即`dp[k - 1][m - 1]`，
没碎的问题就变成了，剩下`k`个鸡蛋，移动`m - 1`次能确定的楼层数量，即`dp[k][m - 1]`，
加上本次，得到状态转移方程：
```
dp[i][m] = dp[i - 1][m - 1] + dp[i][m - 1] + 1
```
那么只要 dp 的值大于等于楼层 N 就能得到结果：
```javascript
var superEggDrop = function (K, N) {
  const dp = new Array(K + 1).fill(new Array(N + 1).fill(0));
  let m = 0;
  while (dp[K][m] < N) {
    ++m;
    for (let i = 1; i <= K; ++i) {
      dp[i][m] = dp[i - 1][m - 1] + dp[i][m - 1] + 1;
    }
  }
  return m;
};
```


## 后记
这道题我是真的看不明白...还得多练多看多理解思想...

## 参考
[LeetCode 887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)





