---
title: 一起扔鸡蛋
tags: [Algorithm]
category: Algorithm
date: 2020-04-07 23:11
---
# 一起扔鸡蛋

## 前言
今天的我又是被算法血虐的一天，来个问题吧：

> 如果有 100 层楼，给你 2 个鸡蛋，鸡蛋很坚硬，从 X 层扔下鸡蛋会碎裂，X 层以下怎么扔都不会碎，你想知道 X 的值，设计方案求最少扔几次？

## 解法分析

### 二分法
二分法可能是一开始很多人想的解决方案，解决方法如下：

在 50 层扔下鸡蛋，如果碎了去 1 层开始扔鸡蛋，如果没碎，去 75 层扔鸡蛋...

最坏情况下，X = 49，在 50 层扔下鸡蛋，鸡蛋碎了，这时候只剩下一个鸡蛋，所以只能从 1 层开始，一直扔到 49 层，这种方法的次数为 50 次。

### 平方根法
从根号 100，即 10 层开始扔鸡蛋，如果没碎就在 20 层扔，如果碎了就从 1 层开始扔...

最坏情况下，X = 100，第一个鸡蛋在第十次碎了，从 91 层开始，直到第 99 层，这种方法次数为 19 次。

### 分析
假设 n 为最坏情况下的次数，那么第一次扔的楼层为 n，有两种情况：
- 碎了，那么接下来需要从`[1, n - 1]`遍历扔，最多扔`n - 1`次
- 没碎，接下来从`[n + 1, 100]`继续考虑怎么扔的问题，最多扔`n - 1`次

如果没碎接下来该怎么扔呢？转化成了在`[n + 1, 100]`层用两个鸡蛋求解的问题，在`n + (n - 1)`层扔：
- 碎了，接下来从`[n + 1, n + (n - 1) - 1]`中扔，最多扔`n - 2`次
- 没碎，接下来从`[n + (n - 1) + 1, 100]`中扔，最多`n - 2`次，在`n + (n - 1) + (n - 2)` 层扔。


继续扔，`n + (n - 1) + (n - 2) + (n - 3) + ....`，最后一次在`n - n - 1`处能够确认，得出方程
```
    n + (n - 1) + (n - 2) + ... + 1
=>  n(n + 1)/2
```
最差情况下，这个方程能够等于 100 层，解方程结果向上取整得`n = 14`。

即最开始以 14 为单位扔鸡蛋。

## 扩散
现在改成把层数和鸡蛋数量都变成变量：
> 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

> 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

> 你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

> 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
> 你的目标是确切地知道 F 的值是多少。

> 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

### 动态规划
这道题打死我都想不到动态规划...

既然是动态规划，那么一定能够找到状态转移方程，设置`dp[K][X]`为最少的扔鸡蛋次数，在第 i 层扔鸡蛋：

- 如果碎了，这时候问题转化为在 N - 1 层中使用 K - 1 个鸡蛋，为`dp[K - 1][i - 1]`
- 如果没碎，这时候问题转化为在 [i + 1, N] 共 N - i 层中使用 K 个鸡蛋，为`dp[K][N - i]`

基础条件是：
- 当层数只有 1 的时候，数量为 1 次
- 当鸡蛋只有一个的时候，必须从 1 层开始扔，数量为 N 次

所以实现...实现我也没看懂，等我真正看懂了我再更新这篇文章吧..






