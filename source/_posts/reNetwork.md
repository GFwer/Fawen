---
title: reNetwork
tags: [network]
category: Network
date: 2020-04-06 22:11
---
# reNetwork


## 前言
网络的知识很多都忘了，导致现在记忆很零碎，所以有了这篇文章，整理 + 学习。

## OSI 和 TCP/IP

### OSI 模型
OSI 将整个计算机网络体系分成七层，分别是：
 - 应用层，该层提供为应用软件而设置的接口
 - 表达层，为不同格式的应用层提供语法语义映射
 - 会话层，建立、管理和终止本地和远程应用程序之间的连接
 - 传输层，提供可变长度的数据序列从源传送到目的地主机
 - 网络层，决定数据的路径选择和转寄，形成报文
 - 数据链路层，负责网络寻址、错误侦测和改错
 - 物理层，物理传输介质

### TCP/IP 四层
TCP/IP 从互联网通信的角度分成四层：
- 应用层，主要协议有`HTTP`、`SMTP`、`SSH`、`FTP`等
- 传输层、主要协议有`TCP`、`UDP`等
- 网际层，主要协议有`IP`
- 网络接口层

两者的映射关系大概可以如下图：
```
---------------------
应用层     |
表达层     |    应用层
会话层     |
---------------------
传输层     |    传输层
---------------------
网络层     |    网际层
---------------------
数据链路层
          |  网络接口层
物理层
---------------------
```

## 建立连接和断开连接
### 三次握手
三次握手主要目的就是让客户端和服务端明确双方都能正常地收发信息，才能保证 TCP 的可靠链接。
做了个图来描述三次握手：

![三次握手](https://static.gongfangwen.com/2020-04-06-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-2.png)


流程如下：
1. 客户端发送 SYN 报文，其中初始序号 seq = x
2. 服务端收到报文以后，回应自己的 SYN 报文，同时把收到的 seq + 1 作为 ack 的值，表示已经收到了客户端的 SYN，确认号 ack = x + 1，初始序号 seq = y
3. 客户端收到报文，发送一个 ACK 报文，把收到的初始序号加 1，确认号 ack = y + 1，seq = x + 1

至此可以确认双方收发正常，开始通信。
> - 在建立连接的时候，任意一方没响应，TCP 都会重发 SYN 包
> - 如果两次握手的话，客户端第一次发由于网络延迟服务端没收到，客户端重发，服务端收到了，连接断开之后服务端收到了客户端延迟的包，发送 ACK 就建立了连接，但是这时候客户端已经关闭了，白白浪费了资源
> - SYN Flood，攻击者持续向服务端发送大量 SYN 包，服务端对每个 SYN 都预留了端口和资源并返回了 ACK 包，客户端不接收，服务端资源被占用完，无法响应正常建立连接的请求。

### 四次挥手
断开连接需要先进行四次挥手，可以由客户端发起，也可以由服务端发起。

![四次挥手](https://static.gongfangwen.com/2020-04-06-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

流程如下：
1. 客户端发送 FIN 包，告诉服务端自己要关闭连接，附上序号 seq = q
2. 服务端收到，发送 ACK 告诉客户端确认收到了 FIN 包，ack = q + 1
3. 服务端发送自己的 FIN 包，seq = p
4. 客户端收到，发送 ACK 告诉服务端确认收到了 FIN 包，ack = p + 1 ，客户端等待 2 MSL（Maximum Segment Lifetime，报文段最大生存时间，如果这个包丢了服务端会发送超时重传的 FIN，客户端再传一次，保证双方都正常关闭） 后关闭连接
5. 服务端收到，关闭连接

## HTTPS
首先来看看 HTTPS，HTTPS 实际上就是加上 SSL/TLS 的 HTTP。
HTTPS 报文中的任何东西都被加密，包括所有报头和荷载

一般来说有两种加密算法：
### 对称加密
客户端加密和服务端解密都使用相同的秘钥。
优点：是算法公开，计算量较小，加密效率高
缺点：是由于使用相同的秘钥，那么秘钥肯定要传输，传输的过程中就可能会泄密；秘钥管理较为困难；

### 非对称加密
非对称加密指的是使用一对公钥和私钥，公钥能解开私钥加密的消息，私钥能解开公钥的消息，其他人均无法解开，加密过程如下：
1. 客户端发起请求，服务器将公钥明文返回给客户端
2. 客户端生成一个密钥 X，用公钥加密后发送给服务端
3. 服务端时候收到了加密的密钥 X，用公钥解开
4. 这样只有双方才有秘钥 X，通过秘钥 X 进行加密传输（对称加密传输）

所以，实际上 HTTPS 是对称加密和非对称加密都是用了的，非对称加密更能保证安全性，不过相对的，速度要慢上许多。

### 证书
看上去使用了两种机密算法很安全了，实际上中间人是能得到密钥 X 的，流程如下：
1. 客户端发起请求，服务器明文返回公钥
2. 中间人截获公钥，把数据包中的公钥替换成自己的公钥 Y，发送给客户端
3. 客户端使用公钥 Y 加密自己随机生成的密钥 X，发送给客户端
4. 中间人截获加密后的秘钥 X，用私钥 Y 解密了秘钥 X，再用公钥 X 加密传给服务器
5. 服务器使用自己的私钥解密获得密钥 X
6. 中间人拿到了密钥 X

这时候想要识别出中间人，那么就要有一个身份证来证明你是你，于是就有了数字证书。

如何能证明这个“身份证”不是伪造的呢？

### 数字签名。

数字签名制作过程如下：
1. CA 机构拥有一对私钥和公钥
2. CA 生成证书，内容包括网站域名和网站其他信息，对证书明文信息进行 hash
3. 对 hash 后的内容使用私钥加密，得到数字签名
4. CA 把证书明文和数字签名颁发给网站

浏览器是如何验证证书是否可行的？
1. 浏览器拿到证书，得到明文 T1，数字签名 S1
2. 由于 CA 机构是浏览器信任的，浏览器持有它的公钥，用公钥解密数字签名 S1，得到 S2
3. 用证书中说明的 hash 算法对证书明文 T1 进行 hash，得到 T2
4. 比较 T2 是否等于 S2，相等则证明证书可信任

中间人有两种攻击方式：
1. 篡改证书，但是没有私钥无法加密签名，浏览器收到后，对比 T2 不等于 S2，攻击失败
2. 替换证书，中间人自己也申请了一套证书，把这个证书替换后发给客户端，但是证书内容有网站域名信息，攻击失败

如何证明 CA 的公钥可信？
操作系统或者浏览器会预装一些信任的 CA 机构证书，保证公钥可信？


## HTTP/2
### HTTP 1.1 存在的问题
1. TCP 连接数限制
2. 线头阻塞，每个 TCP 连接同时只能处理一个请求、相应，如果上一个响应没到，那么下一个请求便会受阻
3. Header 头内容多，Header 头内容变化不大，但是还是全量传输

### HTTP 2 特性

1. 二进制分帧层，以二进制代替明文传输，报文被分为更小的数据帧，到达后再重组
2. 多路复用，在每个帧中标明了属于哪个流的数据，使得多个流的数据可以同时传输，解决了线头阻塞问题，同时只需要一个 TCP 连接就行了
3. 服务器推送，客户端可以缓存/拒绝推送过来的资源，同时可以由多个页面共享
4. Header 压缩（HPACK 算法），把头部(name: value 形式)字段转化为映射，通用部分节约传输
5. 优先级设置，对流可以设置优先级，关键请求不被阻塞
6. 流量控制，每个流都有自己的流量窗口，在窗口被扩大前，最多只允许发送这么多数据

不过 HTTP/2 没有完全解决线头阻塞问题，如果出现丢包，整个 TCP 管道都要开始等待重传，同时如果要使用 TLS 加密，还要增加额外的握手时间。

## HTTP/3
HTTP/3 不再使用 TCP 作为会话的传输层，而是使用 QUIC（基于 UDP，Quick UDP Internet Connections），大部分 HTTP/2 的功能都能简单的映射到 QUIC 上（HPACK 变成全新的 QPACK）。

同时 QUIC 还结合了 3 次握手和 TLS 1.3 握手，使得默认情况下就提供加密认证。

## 参考
- [彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231)
- [HTTP/3：过去，现在，还有未来](https://blog.cloudflare.com/zh/http3-the-past-present-and-future-zh/)