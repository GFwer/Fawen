---
title: JavaScript 与 IEEE 754 标准
tags: [Javascript]
category: JavaScript
date: 2020-3-19 22:50
---
# JavaScript 与 IEEE 754 标准

## 前言
之前对于 IEEE 754 没理解清楚，诸如`MAX_VALUE`、`SAFE_VALUE`等，趁着之前机器码一起仔细了解了。

## 0.1 + 0.2 = ?
这算是最著名的一个问题了，包括 JavaScript，所有使用 IEEE 754 浮点数标准的语言中，0.1 + 0.2 都不会等于0.3。

## IEEE 754
IEEE 754 中最常用的浮点数表示法包括单精度（32 位）和双精度（64 位），JavaScript 采用的是双精度。

### 浮点数的二进制表示
十进制整数的二进制转换采用**除二取余法**，如 6 的二进制表示为：
```javascript
// 6 / 2 = 3 余 0
// 3 / 2 = 1 余 1
// 1 / 2 = 0 余 1
// 逆序排列得到 '110'
console.log(Number(6).toString(2)) // '110'
// 6 = 1 * (2 ** 2) + 1 * (2 ** 1) + 0 * (2 ** 0) = 4 + 2 + 0
```
十进制小数的二进制转换采用**乘二取余法**，如 0.8125 的二进制表示为：
```javascript
// 0.8125 * 2 = 1.6250 取整数 1
// 0.6250 * 2 = 1.2500 取整数 1
// 0.2500 * 2 = 0.5000 取整数 0
// 0.5000 * 2 = 1.0000 取整数 1
// 顺序排列得到 0.1101
console.log((0.8125).toString(2)); // '0.1101'
// 0.8125 = 1 * (2 ** -1) + 1 * (2 ** -2) + 0 * (2 ** -3) + 1 * (2 ** -4)
```

如果要求 0.1 的二进制表示呢？按照上面的方法来试一下：
```javascript
// 0.1 * 2 = 0.2 取整数 0
// 0.2 * 2 = 0.4 取整数 0
// 0.4 * 2 = 0.8 取整数 0
// 0.8 * 2 = 1.6 取整数 1
// 0.6 * 2 = 1.2 取整数 1
// 0.2 * 2 = 0.4 取整数 0
// .............
```
能够发现，乘着乘着开始循环了（禁止套娃！），所以 0.1 的二进制表示就是：`0.0001100110011....`，数是求出来了，但是计算机中的数都是有长度的，所以 0.1 在计算机存储中是被裁剪掉的。

### 浮点数的存储与精度丢失
IEEE 754 的浮点数表示三个域如下图：
![三个域](https://static.gongfangwen.com/2020-03-19-2880px-General_floating_point_frac.svg.png)

IEEE 754 认为，一个浮点数可以由`sign`、`exponent`、`fraction`来表示，首先所有浮点数都可以转化成 `1.xxx * (2 ** n)`的形式表示。
 - 符号位 sign，最高位，0 表示正数，1 表示负数；
 - 指数位 exponent，第 2 ~ 12 位，表示 2 的次方数，长度为 11，如果只存储正数，那么其范围是`[0,2047]`(保留 0 与 2047)，如果有符号，那么其范围是`[-1022,1023]`，为了不加上符号位妨碍计算，可以加上一个偏移量，即 `10000000000 ~ 11111111110`（1024 ~ 2046）表示正数，`00000000001 ~ 01111111110`(1 ~ 1022)表示负数。所以`exponent = E + bias`，其中`bias = 2 ** (11 - 1) - 1 = 1023`，`E`等于上述的`n`。
 - 尾数位 fraction，第 13 ~ 64 位，即上述所说的转化成`1.xxx * (2 ** n)`的形式，可舍去小数点之前，后面的`xxx`就是尾数。

其中对于指数位
对于 0.1 这个例子，尝试求一下各个值：
```
0.1 = 0.0.0001100110011....
    = 1.100110011001100.... * (2 ** -4)
符号位 sign = 0
指数位 exponent = E - bias = -4 + 1023 = 1019 = 01111111011
尾数位 fraction = 1001100110011....
```
再把 0.1 用 IEEE 754 的图可以这样表示，注意最后需要“零舍一入”，将`0011`变成`010`：
```
  0 01111111011 1001100110011001100110011001100110011001100110011010
```
同理求 0.2 的二进制表示：
```javascript
// 0.2 * 2 = 0.4 取整数 0
// 0.4 * 2 = 0.8 取整数 0
// 0.8 * 2 = 1.6 取整数 1
// 0.6 * 2 = 1.2 取整数 1
// 0.2 * 2 = 0.4 取整数 0
// ..........
// 0.2 = 0.001100110011.... = 1.100110011... * (2 ** -3)
// sign = 0
// exponent = E + bias = -3 + 1023 = 1020 = 01111111100
// fraction = 1001100110011001100110011001100110011001100110011010
// 0 01111111100 1001100110011001100110011001100110011001100110011010
```

### 浮点数计算
计算`0.1 + 0.2`：
#### 对阶
原则是小阶对大阶，0.1 的 -4 向右移一位：
```
  1.1001100110011001100110011001100110011001100110011010 * (2 ** -4)
= 0.1100110011001100110011001100110011001100110011001101 * (2 ** -3)
```
#### 尾数加法
```
   0.1100110011001100110011001100110011001100110011001101
+  1.1001100110011001100110011001100110011001100110011010
= 10.0110011001100110011001100110011001100110011001100111
= 10.0110011001100110011001100110011001100110011001100111 * (2 ** -3)
```
#### 规格化处理
```
  10.0110011001100110011001100110011001100110011001100111 * (2 ** -3)
=  1.0011001100110011001100110011001100110011001100110100 * (2 ** -2)
```
#### 结果
用 IEEE 754 表示为：
```
0 01111111101 0011001100110011001100110011001100110011001100110100
```
换算成 10 进制表示为：
```
// 0.30000000000000004440892098500626
console.log((0.1 + 0.2).toPrecision(32));
// 0.30000000000000004440892098500626
```

得出了 `0.1 + 0.2 != 0.3`

### Number.MAX_VALUE 与 Number.MIN_VALUE
根据 IEEE 754，可求得一个最大值和最小值，其中：
- 最大值 sign 等于 0，exponent 等于 1023，尾数全部为 1 的时候可以获取到最大值`MAX_VALUE`，其值等于`(-1)**0 * 2**1023 * (Number.parseInt( "1".repeat(53) ,2) * 2**-52)`;
- 最小值 sign 等于 0 ，exponent 等于 -1022，尾数只有最后一位为 1 的时候可以获取到不为零的最小正值`MIN_VALUE`,其值等于`(-1)**0 * 2**-1022 * (Number.parseInt( "0".repeat(52)+"1" ,2) * 2**-52)`

### Number.MAX_SAFE_VALUE 和 Number.MIN_SAFE_VALUE
要确定安全整数范围，基于 IEEE 754 可以得出，尾数最大位数为 52，加上省略的 1 位整数，一共 53 为，可以得到安全整数范围是(-2^53, 2^53)不包两端，即：
> Number.MAX_SAFE_VALUE = 2^53 - 1 = 9007199254740991


即超过这个数的运算都是不安全的，计算结果不能保证其正确性，可能会发生这种情况：
```javascript
console.log(Number.MAX_SAFE_INTEGER + 2 === Number.MAX_SAFE_INTEGER + 1); // true
```
[转载一个解释]()：
> ![为什么不安全](https://static.gongfangwen.com/2020-03-19-15846295776451.jpg)



## 参考
- [维基百科](https://zh.wikipedia.org/wiki/IEEE_754)
- [JavaScript 深入系列之浮点数精度](https://zhuanlan.zhihu.com/p/113493572)
- [numberInJavaScript](http://www.yangshengdonghome.com/2016/06/19/numberInJavaScript/)
- [IEEE754 浮点数格式 与 Javascript number 的特性](https://segmentfault.com/a/1190000008268668)
- [JavaScript 关于 IEEE 754 双精度浮点数的实现](https://blog.windstone.cc/front-end/js/data-structure/number/js-number-implementation.html)