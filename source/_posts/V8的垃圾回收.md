---
title: V8 中的垃圾回收 
tags: [JavaScript,V8]
category: JavaScript
date: 2020-3-17 17:59
---

# V8中的垃圾回收机制

## 前言
上一篇讲了 JS 的垃圾回收机制，那么实际在 V8 中是怎么做的呢？

## 弱分代假设
有这么一句陈述，**大部分对象的生命周期短，少部分对象的生命周期长或常驻内存**，基于这个理论可以将内存分为新生代和老生代，针对这两个不同分类的内存执行不同的算法，可以更有效率。

## 算法
### 针对新生代的算法
#### Scavenge 算法
Scavenge（清道夫）算法使用在新生代内存空间中，目的是目的是尽可能快地释放内存，以**空间换时间**。
1. 具体来说的话，将新生代的空间一分为二，一个空间称为 From 空间，另一个空间称为 To 空间；
2. 内存分配时先把对象分配至 From 空间；
3. 开始垃圾回收的时候，先检查 From 空间的存活的对象，这些对象会被复制到 To 空间中，然后清理非存活的对象；
4. From 和 To 空间角色互换。

##### 晋升
新生代移动到老生代称为晋升。
1. 如果一个对象经历过了二次从 From 空间复制到 To 空间的话，那么它将会被移动到老生代的内存中。
2. 如果在复制的时候，发现 To 空间以已经使用了 25%，那么将这个对象移到老生代空间中。

### 针对老生代的算法
对于老生代来说，没必要使用在新生代中使用的那种“以空间换时间”的算法，在于老生代中生命周期比较长的对象，这种方法无疑效率很低。
#### Mark-Sweep 算法
Mark-Sweep 就是之前提过的标记-清除算法，在垃圾回收的时候，先标记存活的对象，之后清理没标记的对象。
标记-清除算法有一个问题，那就是垃圾回收后，内存空间可能会出现不连续的情况，可能会对后续的内存分配造成问题。

#### Mark-Compact 算法
Mark-Compact 算法基于标记清除法改进而来，主要目的就是解决内存空间不连续情况。
它会在标记完存活的对象之后会进行一次整理，将标记为活着的对象往内存空间的一端移动，在移动完成后，清理边界外的内存。

Mark-Compact 虽然避免了不连续问题，但是速度上较慢，所以 V8 在实际执行的时候主要使用 Mark-Sweep 算法，当内存空间不够的时候才会使用 Mark-Compact 算法。
#### Incremental Marking 算法
在进行分代垃圾回收的时候，三种垃圾回收算法在运行的时候都需要暂定应用逻辑，防止出现前后不一致情况，对于新生代来说影响较小，对于老生代来说影响较大。
所以实际上标记的时候 V8 采用增量标记（Incremental Marking），即将标记拆分成许多小步，每完成一小步，就让 JS 应用逻辑执行一会，这样能保证应用不阻塞。
## 参考
[掘金](https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-12)
[知乎](https://zhuanlan.zhihu.com/p/113296268)